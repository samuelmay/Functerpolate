<html>

<head>
<title>Functerpolate Manual</title>
</head>

<body>
<h1>Functerpolate</h1>

<p>Functerpolate is a set of tools to perform statistical regressions and
interpolation on data, and investigate the running time of programs.</p>

<p>There are three interfaces to functerpolate: the main 'functerpolate' script,
the 'complexity' script, and using the clojure library directly. In the future,
a Java interface may be added.</p>

<h2>Setup and Installation</h2>

<p><strong>The Hard Way:</strong>Three dependancies are required: The clojure
language, the clojure-contrib clojure library, and the OpenChart2 java plotting
library. All these jar files must be in your java classpath. From the
Functerpolate top level directory, run something like:
<pre>
java -cp .:/path/to/clojure.jar:/path/to/clojure-contrib.jar/:/path/to/openchart2.jar clojure.main [functerpolate script] [arguments]
</pre>
</p>

<p><strong>The Easy Way:</strong>Make sure you have the latest Java version
installed. Download the 'kitchen sink' version, and cd into the Functerpolate
top level directory. On Linux or Mac (from a terminal), run:
<pre>
./functerpolate.sh [arguments]
</pre>
On Windows (from the command prompt) run:
<pre>
./functerpolate.batch [arguments]
</pre>
There are also equivalent script and batch files for the 'complexity' script.
</p>

<h2>functerpolate</h2>

<p>Reads in numbers from standard input. If there are two or more numbers on a
line of input, the first two numbers are interpreted as an (x,y) pair and added
to the data set. If there is only one number on a line, it is interpreted as an
x value for which the equivalent y value should be estimated.</p>

<p>Y values can be estimated in several ways. Either interpolation or regression
can be performed. For interpolation, a nth-order polynomial is found that fits
the given points exactly, using the method
of <a href="http://en.wikipedia.org/wiki/Lagrange_polynomial">Lagrange
polynomials</a>. For regression, a curve is found that fits the data best in a
least-squares sense. Linear, exponential and logarithmic regressions are
available.</p>

<p>Either the 'interpolate' option must be given, or a regression must be
specified using the 'regression' option.</p>

<p><em>Example of use</em>
<pre>
samwise@hex in functerpolate $ clj functerpolate.clj
interpolator -- interpolate and extrapolate values from a dataset
Options
  --regression, -r &lt;arg&gt;  Use the given regression method to fit a least-squares
                          line of best fit. Linear, logarithmic, and exponential
                          regressions are available, as well as 'best' which
                          will try to choose the best regression.
  --interpolate, -i       Instead of performing a least-squares regression, fit
                          a polynomial that passes through all the given points
                          exactly, using Lagrange interpolation.

  --plot, -p              Plot the data set, fitted function, and interpolated
                          points.
  --quiet, -q             Print out just the interpolated data, nothing else
                          thanks.
samwise@hex in functerpolate $ clj functerpolate.clj -r linear -p
0 1
1 2
2 3
3
4 5
-- Results of  linear regression --
Function:                      y = 1.000000x+1.000000
Coefficient of detirmination:  1.0
Regression sum of squares:     8.75
Interpolated values:
3.0 4.0
</pre>
<img src="results1.png" title="Plot of regression results" />
<p>
<h2>complexity</h2>

<p>Investigate the time complexity of a given program. To do this, a second
program is needed that will generate input for the first, given a number
representing the size of the input. Then, the first program is run for a range
of input sizes (the input being generated by the second program), and
timed. Multiple runs are performed for each input size, and the times averaged,
to generate more accurate data.</p>

<p><em>Example of use</em>
<pre>
samwise@hex in functerpolate $ clj complexity.clj
complexity.clj: attempt to detirmine the time complexity vs input size for a
given program.

The required arguments are:
 - an executable program to test
 - a second program that, given a number as an argument, will generate
   appropriate input of that size for the first program.

Options
  --start, -s <arg>        starting input size
  [default 100]
  --limit, -l <arg>        final input size
  [default 1000]
  --points, -p <arg>       number of data points to collect
  [default 10]
  --runs, -r <arg>         how many times to run the program for each data point
  [default 10]
  --plot, -p               if given, create a graphical plot of the results     
  --extrapolate, -e <arg>  a list of bigger input sizes to extrapolate for
samwise@hex in functerpolate $ ./genrandom 5
5
420
216
936
994
190
samwise@hex in functerpolate $ ./genrandom 5 | ./isort
Enter number of elements
Enter elements to be sorted

Array before sorting
 856 752 257 7 955

Insertion sort

Array after sorting
 7 257 752 856 955
samwise@hex in functerpolate $ clj complexity.clj --plot --start 10000 --limit 30000 --runs 5 --extrapolate 40000,50000 ./isort ./genrandom
The suggested complexity is O(N), or linear-time.
Input size    Average runtime over 5 runs
10000         1.083128s
12222         1.590186s
14444         2.201796s
16666         2.864993s
18888         3.702366s
21111         4.638832s
23333         5.597922s
25555         6.568676s
27777         7.735341s
30000         8.961043s
Input size    Predicted runtime
40000         12.397597s
50000         16.349103s
</pre>
<img src="results2.png" title="Plot of complexity analysis results" />
</p>
<h2>The functerpolate library</h2>

<p>The internal functerpolate clojure libraries can be used if the functerpolate
top-level directory is in the classpath. There are four: interpolate,
regression, complexity, and plot. Here are listings of the avaliable
functions. For further information, read the docstrings for each function.</p>

<p><strong>functerpolate.interpolate:</strong> function
'lagrange-interpolation-fn'</p>

<p><strong>functerpolate.regression:</strong> function 'linear-regression',
struct 'regression-fit', multi function 'fit-model' with methods for models
':Linear',':Exponential', ':Logarithmic', and ':Best'.</p>

<p><strong>functerpolate.complexity:</strong> multi function 'runtime', with
methods for clojure functions and external programs, struct
'complexity-analysis', function 'complexity'</p>

<p><strong>functerpolate.plot:</strong> struct 'plot', function
'function-plot-series', macro 'with-new-plot, macro 'with-plot'. Functions
available to use with the plot macros: 'add-data', 'add-function', 'add-label',
'add-caption', 'make-honest', 'make-visible', 'update', 'exit-on-close'.</p>

</body>
</html>
