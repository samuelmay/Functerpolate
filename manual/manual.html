<html>

<head>
<title>Functerpolate Manual</title>
</head>

<body>
<h1>Functerpolate</h1>

<p>Functerpolate is a set of tools to perform statistical regressions and
interpolation on data, and investigate the running time of programs. An archive
with everything you need is
available <a href="http://www.cse.unsw.edu.au/~ssbm955/functerpolate/functerpolate-0.0.1.zip">here</a>. The
latest <a href="http://git-scm.com/">git</a> sources are available
from <a href="http://github.com/samuelmay/Functerpolate/tree/master">github</a>.</p>

<p>There are three interfaces to functerpolate: the main 'functerpolate' script,
the 'complexity' script, and using the clojure library directly. In the future,
a Java interface may be added.</p>

<h2>Setup and Installation</h2>

<p><strong>The Hard Way:</strong> Three dependancies are required:
The <a href="http://code.google.com/p/clojure/downloads/list">clojure
language</a>,
the <a href="http://github.com/richhickey/clojure-contrib/tree/master">clojure-contrib
clojure library</a> (which must be built from source at the moment),
the <a href="http://www.jfree.org/jfreechart/download.html">JFreeChart java
plotting library</a>, and the JCommon java library (included with
JFreeChart). All these jar files must be in your java classpath. From the
Functerpolate top level directory, run something like:
<pre>
java -cp .:/path/to/clojure.jar:/path/to/clojure-contrib.jar/:/path/to/jfreechart-version.jar:/path/to/jcommon-version.jar clojure.main [functerpolate script] [arguments]
</pre>
</p>

<p><strong>The Easy Way:</strong> Make sure you have the latest Java version
installed. Download the 'kitchen sink' archive, unzip it, and cd into the
functerpolate top-level directory. On Linux or Mac (from a terminal), run:
<pre>
./functerpolate.sh [arguments]
</pre>
On Windows (from the command prompt) run:
<pre>
./functerpolate.batch [arguments]
</pre>
There are also equivalent script and batch files for the 'complexity' script.
</p>

<h2>functerpolate</h2>

<p>Reads in numbers from standard input. If there are two or more numbers on a
line of input, the first two numbers are interpreted as an (x,y) pair and added
to the data set. If there is only one number on a line, it is interpreted as an
x value for which the equivalent y value should be estimated.</p>

<p>Y values can be estimated in several ways. Either interpolation or regression
can be performed. For interpolation, a nth-order polynomial is found that fits
the given points exactly, using the method
of <a href="http://en.wikipedia.org/wiki/Lagrange_polynomial">Lagrange
polynomials</a>. For regression, a curve is found that fits the data best in a
least-squares sense. Linear, exponential and logarithmic regressions are
available.</p>

<p>Either the 'interpolate' option must be given, or a regression must be
specified using the 'regression' option.</p>

<p><em>Example of use</em>
<pre>
samwise@hex in functerpolate $ ./functerpolate.sh
interpolator -- interpolate and extrapolate values from a dataset
Options
  --regression, -r &lt;arg&gt;  Use the given regression method to fit a least-squares
                          line of best fit. Linear, logarithmic, and exponential
                          regressions are available, as well as 'best' which
                          will try to choose the best regression.
  --interpolate, -i       Instead of performing a least-squares regression, fit
                          a polynomial that passes through all the given points
                          exactly, using Lagrange interpolation.

  --plot, -p              Plot the data set, fitted function, and interpolated
                          points.
  --quiet, -q             Print out just the interpolated data, nothing else
                          thanks.
samwise@hex in functerpolate $ ./functerpolate.sh -r linear -p
0 1
1 2
2 3
3
4 5
-- Results of  linear regression --
Function:                      y = 1.000000x+1.000000
Coefficient of detirmination:  1.0
Regression sum of squares:     8.75
Interpolated values:
3.0 4.0
</pre>
<img src="results1.png" title="Plot of regression results" />
<p>
<h2>complexity</h2>

<p>Investigate the time complexity of a given program. To do this, a second
program is needed that will generate input for the first, given a number
representing the size of the input. Then, the first program is run for a range
of input sizes (the input being generated by the second program), and
timed. Multiple runs are performed for each input size, and the times averaged,
to generate more accurate data.</p>

<p><em>Example of use</em>
<pre>
samwise@hex in functerpolate $ ./complexity.sh
complexity.clj: attempt to detirmine the time complexity vs input size for a
given program.

The required arguments are:
 - an executable program to test
 - a second program that, given a number as an argument, will generate
   appropriate input of that size for the first program.

Options
  --start, -s <arg>        starting input size
  [default 100]
  --limit, -l <arg>        final input size
  [default 1000]
  --points, -p <arg>       number of data points to collect
  [default 10]
  --runs, -r <arg>         how many times to run the program for each data point
  [default 10]
  --plot, -p               if given, create a graphical plot of the results     
  --extrapolate, -e <arg>  a list of bigger input sizes to extrapolate for
samwise@hex in functerpolate $ ./genrandom 5
5
420
216
936
994
190
samwise@hex in functerpolate $ ./genrandom 5 | ./isort
Enter number of elements
Enter elements to be sorted

Array before sorting
 856 752 257 7 955

Insertion sort

Array after sorting
 7 257 752 856 955
samwise@hex in functerpolate $ ./complexity.sh --plot --start 10000 --limit 30000 --runs 5 --extrapolate 40000,50000 ./isort ./genrandom
The suggested complexity is O(e^N), or exponential-time.
Input size    Average runtime over 5 runs
10000         1.101127s
12222         1.574126s
14444         2.179658s
16666         2.903265s
18888         3.631173s
21111         4.494486s
23333         5.478675s
25555         6.714245s
27777         7.984175s
30000         9.211676s
Input size    Predicted runtime
40000         29.791387s
50000         84.502785s
</pre>
<img src="results2.png" title="Plot of complexity analysis results" />
</p>
<h2>The functerpolate library</h2>

<p>The internal functerpolate clojure libraries can be used if the functerpolate
top-level directory is in the classpath. There are four: interpolate,
regression, complexity, and plot. Here are listings of the avaliable
functions. For further information, read the docstrings for each function.</p>

<p><strong>functerpolate.interpolate:</strong> function
'lagrange-interpolation-fn'</p>

<p><strong>functerpolate.regression:</strong> function 'linear-regression',
struct 'regression-fit', multi function 'fit-model' with methods for models
':Linear',':Exponential', ':Logarithmic', and ':Best'.</p>

<p><strong>functerpolate.complexity:</strong> multi function 'runtime', with
methods for clojure functions and external programs, struct
'complexity-analysis', function 'complexity'</p>

<p><strong>functerpolate.plot:</strong> struct 'plot', function
'function-plot-series', macro 'with-new-plot, macro 'with-plot'. Functions
available to use with the plot macros: 'add-data', 'add-function', 'add-label',
'add-caption', 'make-honest', 'make-visible', 'update', 'exit-on-close'.</p>

</body>
</html>
